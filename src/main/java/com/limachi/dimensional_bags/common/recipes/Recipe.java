package com.limachi.dimensional_bags.common.recipes;

import com.google.gson.JsonObject;
import net.minecraft.block.Blocks;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.*;
import net.minecraft.network.PacketBuffer;
import net.minecraft.util.NonNullList;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.World;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.function.BiFunction;
import java.util.function.Function;

public class Recipe implements IRecipe { //note: all recipes generated by this class are unserializable (so not configurable via datapack), this class should be used only for recipes that can't be donne via the vanilla system

    private final ResourceLocation ID;
    private final String GROUP;
    private final IRecipeType<?> TYPE;
    private final ItemStack ICON;
    private final NonNullList<Ingredient> INGREDIENTS;
    private final NonNullList<ItemStack> REMAINDER;
    private final int[] GRID;
    private final Function<IInventory, ItemStack> RESULT;
    private final BiFunction<IInventory, World, Boolean> MATCHER;
    private final ResourceLocation NAME;
    private final IRecipeSerializer<?> SERIALIZER;

    public Recipe(ResourceLocation name, ItemStack icon, IRecipeType<?> type, String group, int[] grid, NonNullList<Ingredient> ingredients, NonNullList<ItemStack> remainder, BiFunction<IInventory, World, Boolean> matcher, Function<IInventory, ItemStack> result) {
        this(null, icon, type, group, grid, ingredients, remainder, matcher, result, name, null);
    }

    private Recipe(ResourceLocation id, ItemStack icon, IRecipeType<?> type, String group, int[] grid, NonNullList<Ingredient> ingredients, NonNullList<ItemStack> remainder, BiFunction<IInventory, World, Boolean> matcher, Function<IInventory, ItemStack> result, ResourceLocation name, IRecipeSerializer<?> serializer) {
        this.ID = id;
        this.ICON = icon;
        this.TYPE = type;
        this.GROUP = group;
        if (grid.length != 2)
            this.GRID = new int[]{type == IRecipeType.CRAFTING ? 3 : type == IRecipeType.SMITHING ? 2 : 1, type == IRecipeType.CRAFTING ? 3 : 1};
        else
            this.GRID = grid;
        this.INGREDIENTS = ingredients;
        this.REMAINDER = remainder;
        this.MATCHER = matcher;
        this.RESULT = result;
        this.NAME = name;
        if (serializer == null) {
            class AdvancedRecipeSerializer extends net.minecraftforge.registries.ForgeRegistryEntry<IRecipeSerializer<?>>  implements IRecipeSerializer<Recipe> {
                private final Recipe craft;

                public AdvancedRecipeSerializer(Recipe craft) { this.craft = craft; this.setRegistryName(NAME); }

                @Override
                @Nonnull
                public Recipe read(@Nonnull ResourceLocation recipeId, @Nonnull JsonObject json) { return craft.cloneWithId(recipeId); }

                @Override
                @Nullable
                public Recipe read(@Nonnull ResourceLocation recipeId, @Nonnull PacketBuffer buffer) { return craft.cloneWithId(recipeId); }

                @Override
                public void write(@Nonnull PacketBuffer buffer, @Nonnull Recipe recipe) {}
            }
            this.SERIALIZER = new AdvancedRecipeSerializer(this);
        }
        else
            this.SERIALIZER = serializer;
    }

    @Override
    public boolean matches(@Nonnull IInventory inv, @Nonnull World worldIn) { return this.MATCHER.apply(inv, worldIn); }

    @Override
    @Nonnull
    public ItemStack getCraftingResult(@Nonnull IInventory inv) { return this.RESULT.apply(inv); }

    @Override
    public boolean canFit(int width, int height) { return width >= GRID[0] && height >= GRID[1]; }

    @Override
    public ItemStack getRecipeOutput() { return ItemStack.EMPTY; }

    @Override
    @Nonnull
    public NonNullList<ItemStack> getRemainingItems(IInventory inv) { return REMAINDER; }

    @Override
    @Nonnull
    public NonNullList<Ingredient> getIngredients() { return INGREDIENTS; }

    @Override
    public boolean isDynamic() { return true; }

    @Override
    @Nonnull
    public String getGroup() { return GROUP; }

    @Override
    @Nonnull
    public ItemStack getIcon() { return ICON; }

    @Override
    public ResourceLocation getId() { return ID; }

    public Recipe cloneWithId(ResourceLocation idIn) { return new Recipe(idIn, ICON, TYPE, GROUP, GRID, INGREDIENTS, REMAINDER, MATCHER, RESULT, NAME, SERIALIZER); }

    @Override
    @Nonnull
    public IRecipeType<?> getType() { return this.TYPE; }

    @Override
    public ResourceLocation getName() { return this.NAME; }

    @Override
    @Nonnull
    public IRecipeSerializer<?> getSerializer() { return this.SERIALIZER; }
}
